## 2.3 几何阶段

运行在gpu中的几何阶段负责大部分的逐三角形或逐顶点的计算。此阶段从功能上可分为：顶点着色，投影，裁剪，屏幕映射。见图2.3。

> 图2.3 几何阶段被分为这4个阶段

### 2.3.1 顶点着色

此阶段有两个目标：1是计算所有顶点的位置，2是计算任何程序员想计算的顶点上的数据，例如法向量或者贴图坐标。
传统地做法是，物体的着色是由它的每个顶点的位置、法向量，再根据光照计算得来，并且顶点上就存算得的颜色数据，后续步骤把顶点上的颜色插值到每个像素。
因此，可编程的顶点着色计算单元又称为顶点着色器。在现在的gpu里，所有的着色都是逐像素的，顶点着色阶段不用负责着色方程的计算了，而是变得非常通用。
现在这个阶段只是处理关联在逐顶点的数据。比如使用[4.4]()的方法，可以使用此阶段给一个物体实现动画的效果。

首先介绍位置如何计算，物体从一开始到最后到屏幕上画处理，中间涉及好几个空间，或者说好几个坐标系。
一开始模型在自己的*模型空间*里。
不同模型之间通过*模型变换*关联起来。一个模型可以关联多个这样的变换。这用来实现一个模型对应多个实例的功能。实例可以放在不同的位置上，拥有不同的大小，旋转，而避免复制模型自身数据。

模型变换要变的是模型的顶点和法向量。物体一开始叫做处于模型坐标系，把变换应用上之后，物体就处于世界坐标系，或者说世界空间。世界空间只有一个，模型们都变换完后，就同处于这一个世界空间内。

如前文所述，只有相机看到的东西需要被渲染。相机在世界空间中有位置和朝向。为了解决投影和裁剪，对相机和所有模型要进行*视口变换*。这个变换的目的是把相机放到原点，让它对着负z轴方向拍摄，然后正y方向是上面，正x是右手边。这里使用负z方向，也有使用正z方向的，两种没什么大差别，相互变换也很容易。这里使用哪种位置和方向的定义取决于实际的图形api。这个空间被称作*相机空间*，或者*视口空间*，*eye space（译注：不译）*。图2.4展示了一个定义的例子。模型变换和视口变换的实现都是使用4x4的矩阵，在[c4]()会介绍。我们一定要理解的是，顶点的位置和法向量是程序员想算成多少就能算成多少的。

> 图2.4 懒译，反正展示了最后的相机空间是怎么摆的。

接下来我们要介绍顶点着色的另一个输出。为了渲染出真实场景效果，只渲染物体的位置和形状是不够的，还要考虑他们的外观特性。具体需要考虑每个物体的材质，以及所有光源是如何影响到这个物体的。材质和光照可以用好多方法来建模，简单的可以只是颜色，复杂的可以是某种物理特性的表述。

决定材质和光照产生的效果的步骤叫做*着色*。着色需要在物体的各个点上计算一个*着色方程*。一般来说，这个计算的一部分在几何阶段进行，也有一些在逐像素的阶段进行。很多材质信息可以逐顶点存储，例如位置，法向量，颜色，及其他着色计算需要的数值。顶点着色的结果（包含颜色，向量，材质坐标等数据）传送到像素阶段，插值到像素，然后计算最终表面的着色。

本书[c3]()和[c5]()会深入介绍以gpu顶点着色器来表示的顶点着色。

顶点着色中会进行*投影*和*裁剪*，这两步把视口内的体积（译注：以前说的平截头体）变换成一个单位立方体，坐标从(-1,-1,-1)到(1,1,1)。这个范围也是随意定义的，比如z可以定义成从0到1。这个立方体叫做*规范化的视口体积*（译注：从空间的角度，《引架》里叫齐次裁剪空间）。两个步骤里先进行投影，在gpu里通过顶点着色器进行。一般有两种投影方式，*正交投影*和*透视投影*。如图2.5。正交投影又常被称作平行投影，但是它只是平行投影中的一种。建筑领域还常用其他的一些种，具体懒译。

注意投影也是用矩阵表示的（[4.7]()），因此它可以跟其他的几何变换先结合运算。

正交投影的视口体积是个长方体，正交投影变换把它变换成单位立方体。正交投影的特征是平行线变换后还是平行线。这个变换就是个位移和缩放的组合。

透视投影稍复杂。投影后有近大远小的效果。平行线在视平线处出现灭点。这模仿了人眼感知事物的方式。透视投影的视口体积是平截头体，它也是被变换到单位立方体。两种透视变换都可以用4x4矩阵表示（见[c4]()）。变换完后模型就在*裁剪坐标系*里。它是个齐次坐标系，也是[c4]()会介绍。这一步发生在除以w之前，为了后续功能步骤和裁剪能正常工作，顶点着色器的输出必须是这个类型的（译注：vec4）。

虽然这些变换是把体积变成另一个体积，但是因为后面z轴信息不是存储在图片里，而是在一个叫z-buffer的地方，所以模型还是从3维投影成了2维。z-buffer在[2.5]()中介绍。